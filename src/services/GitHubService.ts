/**
 * GitHubService.ts — Project Manager GitHub operations
 * NEXUS AI v6
 *
 * Only the Project Manager agent uses this service.
 * PM creates the repo after Phase 1A and commits every phase output automatically.
 */

import { loadRepoConfig, saveRepoConfig } from './FileWriterService';

const GH_API = 'https://api.github.com';
const GH_USER_KEY = 'nexus-github-user';

function toBase64Utf8(content: string): string {
    const bytes = new TextEncoder().encode(content);
    const chunkSize = 0x8000;
    let binary = '';
    for (let index = 0; index < bytes.length; index += chunkSize) {
        binary += String.fromCharCode(...bytes.subarray(index, index + chunkSize));
    }
    return btoa(binary);
}

export interface GitHubRepo {
    name: string;
    full_name: string;
    html_url: string;
    default_branch: string;
    owner: { login: string };
}

export interface CommitResult {
    path: string;
    sha: string;
    html_url: string;
}

// ── Internal HTTP helper ──────────────────────────────────────────────────────

async function ghRequest<T>(
    method: string,
    path: string,
    token: string,
    body?: object,
): Promise<T> {
    const resp = await fetch(`${GH_API}${path}`, {
        method,
        headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
            'X-GitHub-Api-Version': '2022-11-28',
        },
        ...(body ? { body: JSON.stringify(body) } : {}),
    });

    const json = await resp.json().catch(() => ({})) as Record<string, unknown>;

    if (!resp.ok) {
        throw {
            status: resp.status,
            message: (json.message as string) ?? `GitHub API error ${resp.status}`,
        };
    }

    return json as T;
}

// ── Repository management ─────────────────────────────────────────────────────

/**
 * Creates a new GitHub repository for the project.
 * Called by PM after Phase 1A.
 *
 * @param projectName   Derived from Phase 1A LLM output
 * @param description   Short project description
 * @param isPrivate     Default: false (public)
 * @returns             Created repo metadata
 */
export async function pmCreateRepo(
    projectName: string,
    description: string,
    isPrivate = false,
): Promise<GitHubRepo> {
    const config = loadRepoConfig();
    if (!config?.token) throw new Error('PM: No GitHub token. Connect GitHub in the Repo panel first.');

    // Sanitize repo name: lowercase, spaces → hyphens, remove special chars
    const repoName = projectName
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .slice(0, 100)
        .replace(/^-+|-+$/g, '') || 'nexus-project';

    const repo = await ghRequest<GitHubRepo>('POST', '/user/repos', config.token, {
        name: repoName,
        description: description || `Generated by NEXUS AI v6`,
        private: isPrivate,
        auto_init: true,   // creates main branch + initial README
    });

    // Persist into repo config so all other services know the target
    const updated = { ...config, repo: repo.name, branch: repo.default_branch };
    saveRepoConfig(updated);

    // Persist user info if not already saved
    if (!localStorage.getItem(GH_USER_KEY)) {
        localStorage.setItem(GH_USER_KEY, JSON.stringify({
            login: repo.owner.login,
            avatar_url: '',
        }));
    }

    console.info(`[PM-GitHub] Repository created: ${repo.full_name}`);
    return repo;
}

/**
 * Commits a single file to the active GitHub repository.
 * Called by PM after each SDLC phase completes.
 *
 * @param filePath      e.g. "docs/phase-1A-FAS.md"
 * @param content       Raw text content
 * @param commitMsg     Commit message
 * @returns             Commit result with SHA and URL
 */
export async function pmCommitFile(
    filePath: string,
    content: string,
    commitMsg: string,
): Promise<CommitResult> {
    const config = loadRepoConfig();
    if (!config?.token) throw new Error('PM: No GitHub token configured.');
    if (!config.owner || !config.repo) throw new Error('PM: No repository configured. PM must call pmCreateRepo first.');

    const branch = config.branch || 'main';
    const apiPath = `/repos/${config.owner}/${config.repo}/contents/${filePath}`;

    // Check for existing file SHA (GitHub requires it for updates)
    let existingSha: string | undefined;
    try {
        const existing = await ghRequest<{ sha: string }>(
            'GET', `${apiPath}?ref=${branch}`, config.token
        );
        existingSha = existing.sha;
    } catch (error) {
        console.warn('[PM-GitHub] Existing file SHA not found. Creating a new file.', error);
    }

    const body: Record<string, string> = {
        message: commitMsg,
        content: toBase64Utf8(content),
        branch,
    };
    if (existingSha) body.sha = existingSha;

    const result = await ghRequest<{
        content?: { sha?: string; html_url?: string; path?: string };
        commit?: { sha?: string };
    }>('PUT', apiPath, config.token, body);

    return {
        path: result.content?.path ?? filePath,
        sha: result.content?.sha ?? result.commit?.sha ?? '',
        html_url: result.content?.html_url ??
            `https://github.com/${config.owner}/${config.repo}/blob/${branch}/${filePath}`,
    };
}

// ── Helpers ───────────────────────────────────────────────────────────────────

/** Derive file extension from phase + language */
export function phaseToFilePath(phaseNumber: string, agentRole: string): string {
    const md = 'md';
    const phaseFileMap: Record<string, string> = {
        '1A': `docs/01a-functional-architecture-sheet.${md}`,
        '1B': `docs/01b-prd-and-user-stories.${md}`,
        '2': `docs/02-team-assembly.${md}`,
        '3A': `docs/03a-architecture-decision-record.${md}`,
        '3B': `docs/03b-brand-and-design-system.${md}`,
        '4': `docs/04-technical-specification.${md}`,
        '5': `docs/05-work-breakdown-structure.${md}`,
        '6A': `src/implementation-phase-6a.ts`,
        '6B': `assets/phase-6b-assets.${md}`,
        '7': `docs/07-code-review.${md}`,
        '8': `docs/08-qa-test-plan.${md}`,
        '9': `docs/09-security-audit.${md}`,
        '10': `docs/10-technical-documentation.${md}`,
        '11': `devops/11-ci-cd-runbook.${md}`,
    };
    return phaseFileMap[phaseNumber] ?? `output/phase-${phaseNumber}-${agentRole}.${md}`;
}

/**
 * Extract a short project name from Phase 1A LLM output.
 * Looks for common patterns: "Project: Foo", "## Foo", first bold **Foo**.
 */
export function extractProjectName(phase1aOutput: string): string {
    const patterns = [
        /project[:\s]+["']?([A-Za-z0-9\s\-_]+)["']?/i,
        /^#+\s+(.+)$/m,
        /\*\*([A-Za-z0-9\s\-_]+)\*\*/,
        /application[:\s]+["']?([A-Za-z0-9\s\-_]+)["']?/i,
    ];
    for (const re of patterns) {
        const m = phase1aOutput.match(re);
        if (m?.[1] && m[1].trim().length > 2) return m[1].trim().slice(0, 60);
    }
    return 'nexus-generated-project';
}
