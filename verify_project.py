# -*- coding: utf-8 -*-
# verify_project.py — generated by NEXUS AI DevOps Agent
# Generated from: FAS.md + Tech Spec + WBS (project-specific)
# NEXUS AI v6 — Veritas Ground Truth System
# MUST RUN before any progress report. Agent cannot report progress
# if exit code != 0. Numbers come from this script, not from narrative.
# Based on: verify_integration.py pattern (Ultra Trader, production-validated)

from __future__ import annotations
import argparse, ast, json, os, sys
from pathlib import Path
from typing import Any

# ── GENERATED FROM TECH SPEC ─────────────────────────────────────────
PROJECT_ROOT = Path(__file__).resolve().parent

# Single entry point — derived from WBS
ENTRY_POINT = PROJECT_ROOT / 'src' / 'extension.ts'      # entry for extension

# Directories to scan
SCAN_DIRS = ['src']

# Directories and files always excluded
SKIP_DIRS  = {'__pycache__', '.git', 'node_modules', 'data', 'config', 'webview-ui'}
SKIP_FILES = {'__init__.py', 'conftest.py', 'setup.py'}

# Critical modules — required services
CRITICAL_MODULES: set[str] = {
    'src/veritas/SanityGate.ts',
    'src/veritas/VeritasRunner.ts',
    'src/behavioral/SilentDropMonitor.ts',
    'src/behavioral/AgentOutputFilter.ts',
    'src/behavioral/NamespacedCache.ts',
    'src/agents/BaseAgent.ts',
    'src/agents/DevilsAdvocateAgent.ts',
    'src/orchestrator/AgentOrchestrator.ts',
    'src/memory/SessionManager.ts'
}

# ── AST IMPORT EXTRACTOR ─────────────────────────────────────────────
def extract_imports(filepath: Path) -> set[str]:
    """Extract all imported module names from a TS/JS file using basic text matching or AST."""
    imports: set[str] = set()
    try:
        source = filepath.read_text(encoding='utf-8', errors='replace')
        import re
        # matches import { ... } from 'path'; or import name from 'path';
        pattern = re.compile(r"from\s+['\"](.*?)['\"]", re.MULTILINE)
        for match in pattern.finditer(source):
            raw_path = match.group(1)
            # Normalize path: remove leading './' or '../' if we want to match absolute
            # For this simple AST, let's just grab the last word or reconstruct it
            if raw_path.startswith('.'):
                try:
                    # Resolve relative to current file's directory
                    resolved = (filepath.parent / raw_path).resolve()
                    # Convert back to relative to project root 'src/'
                    rel_to_root = resolved.relative_to(PROJECT_ROOT)
                    imports.add(str(rel_to_root).replace('\\', '/').removesuffix('.ts'))
                except ValueError:
                    imports.add(raw_path.removesuffix('.ts'))
            else:
                imports.add(raw_path.removesuffix('.ts'))
    except Exception:
        return imports
    return imports

def module_path_to_import(filepath: Path, root: Path) -> str:
    """Convert file path to import path relative to root."""
    rel = filepath.relative_to(root)
    parts = list(rel.parts)
    parts[-1] = parts[-1].replace('.ts', '').replace('.js', '')
    # For TS/JS we usually just use relative paths, but for this mock we normalize it
    return '/'.join(parts)

# ── TRANSITIVE IMPORT RESOLVER (BFS) ─────────────────────────────────
def resolve_transitive_imports(
    entry_point: Path,
    root: Path,
    all_modules: dict[str, Path],
) -> set[str]:
    """BFS from entry_point — finds ALL transitively imported modules."""
    visited: set[str] = set()
    queue: list[Path] = [entry_point]

    while queue:
        current = queue.pop(0)
        current_import = module_path_to_import(current, root)

        if current_import in visited:
            continue
        visited.add(current_import)

        raw_imports = extract_imports(current)
        for imp in raw_imports:
            # Match imports with available modules
            for mod_name, mod_path in all_modules.items():
                if imp in mod_name or mod_name in imp:
                    if mod_name not in visited:
                        queue.append(mod_path)
    return visited

# ── SCANNER ──────────────────────────────────────────────────────────
def scan_modules(root: Path) -> dict[str, Path]:
    """Find all .ts/.js files under SCAN_DIRS."""
    modules: dict[str, Path] = {}
    for scan_dir in SCAN_DIRS:
        dir_path = root / scan_dir
        if not dir_path.exists():
            continue
        for dirpath, dirnames, filenames in os.walk(dir_path):
            dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
            dp = Path(dirpath)
            for f in filenames:
                if (not f.endswith('.ts') and not f.endswith('.js')) or f in SKIP_FILES:
                    continue
                filepath = dp / f
                imp_name = module_path_to_import(filepath, root)
                modules[imp_name] = filepath

    if ENTRY_POINT.exists():
        modules[module_path_to_import(ENTRY_POINT, root)] = ENTRY_POINT

    return modules

# ── CLASSIFIER ───────────────────────────────────────────────────────
def classify_modules(
    all_modules: dict[str, Path],
    wired_imports: set[str],
    root: Path,
) -> dict[str, list[dict[str, str]]]:
    """Classify every module as WIRED / NOT_WIRED / TEST / CONFIG."""
    result: dict[str, list[dict[str, str]]] = {
        'WIRED': [], 'NOT_WIRED': [], 'TEST': [], 'CONFIG': []
    }

    for imp_name, filepath in sorted(all_modules.items()):
        rel = str(filepath.relative_to(root)).replace('\\', '/')

        if 'test' in rel.lower() and ('tests/' in rel.lower() or 'test_' in filepath.name):
            result['TEST'].append({'module': imp_name, 'path': rel})
            continue

        if filepath.name in SKIP_FILES or 'config' in rel.lower():
            result['CONFIG'].append({'module': imp_name, 'path': rel})
            continue

        is_wired = any(
            imp_name == w or imp_name.startswith(w + '/') or w.startswith(imp_name + '/')
            for w in wired_imports
        )

        key = 'WIRED' if is_wired else 'NOT_WIRED'
        result[key].append({'module': imp_name, 'path': rel})

    return result

# ── REPORT ───────────────────────────────────────────────────────────
def print_report(
    classified: dict[str, list[dict[str, str]]],
    critical_modules: set[str],
    verbose: bool = False,
) -> int:
    """Print structured report. Returns exit code."""
    wired = classified['WIRED']
    not_wired = classified['NOT_WIRED']
    tests = classified['TEST']
    configs = classified['CONFIG']
    total = len(wired) + len(not_wired) + len(tests) + len(configs)

    print('=' * 70)
    print('  NEXUS AI — Veritas Ground Truth Report')
    print('=' * 70)
    print(f'  Total modules scanned : {total}')
    print(f'  WIRED     : {len(wired):3d}  ({len(wired)/max(1,total)*100:.0f}%)')
    print(f'  NOT_WIRED : {len(not_wired):3d}  ({len(not_wired)/max(1,total)*100:.0f}%)')
    print(f'  TEST      : {len(tests):3d}')
    print(f'  CONFIG    : {len(configs):3d}')
    print('-' * 70)

    critical_missing: list[str] = []
    for crit in sorted(critical_modules):
        crit_import = crit.replace('.ts', '').replace('\\', '/')
        found = any(
            m['module'] == crit_import or m['module'].startswith(crit_import)
            for m in wired
        )
        if not found:
            critical_missing.append(crit)

    if critical_missing:
        print(f'\n  [CRITICAL] {len(critical_missing)} critical modules NOT WIRED:')
        for cm in critical_missing:
            print(f'    - {cm}')
    else:
        print(f'\n  [OK] All {len(critical_modules)} critical modules are WIRED')

    if verbose:
        print('\n--- WIRED MODULES ---')
        for m in wired:
            print(f"  + {m['path']}")
        print('\n--- NOT WIRED MODULES ---')
        for m in not_wired:
            print(f"  - {m['path']}")

    report = {
        'total': total, 'wired': len(wired), 'not_wired': len(not_wired),
        'critical_missing': critical_missing,
        'exit_code': 1 if critical_missing else 0,
    }

    Path('.nexus/memory').mkdir(parents=True, exist_ok=True)
    Path('.nexus/memory/veritas-report.json').write_text(
        json.dumps(report, indent=2), encoding='utf-8')

    print('=' * 70)
    if critical_missing:
        print(f'EXIT CODE: 1  ({len(critical_missing)} critical modules NOT WIRED)')
        print('Agent cannot declare phase COMPLETE until all CRITICAL are WIRED.')
        return 1
    print('EXIT CODE: 0  (all critical modules WIRED)')
    return 0

# ── MAIN ─────────────────────────────────────────────────────────────
def main() -> int:
    parser = argparse.ArgumentParser(description='NEXUS AI Veritas — module wiring audit')
    parser.add_argument('--verbose', '-v', action='store_true', help='Show all wired and not-wired modules')
    args = parser.parse_args()

    # For development, we create the entry point if it doesn't exist
    if not ENTRY_POINT.exists():
        print(f'[INFO] Entry point not found: {ENTRY_POINT}, creating empty one for now...')
        ENTRY_POINT.parent.mkdir(parents=True, exist_ok=True)
        ENTRY_POINT.write_text("// NEXUS AI Entry Point\n")

    all_modules = scan_modules(PROJECT_ROOT)
    wired_imports = resolve_transitive_imports(ENTRY_POINT, PROJECT_ROOT, all_modules)
    classified = classify_modules(all_modules, wired_imports, PROJECT_ROOT)
    
    return print_report(classified, CRITICAL_MODULES, verbose=args.verbose)

if __name__ == '__main__':
    sys.exit(main())
